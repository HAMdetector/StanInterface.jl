<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide · StanInterface.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>StanInterface.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../home.html">Home</a></li><li><span class="toctext">Manual</span><ul><li class="current"><a class="toctext" href="guide.html">Guide</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Usage-1">Usage</a></li><li class="toplevel"><a class="toctext" href="#Minimal-working-example-1">Minimal working example</a></li><li><a class="toctext" href="#Accessing-the-content-of-Stanfit-objects-1">Accessing the content of Stanfit objects</a></li><li><a class="toctext" href="#Additional-keyword-arguments-1">Additional keyword arguments</a></li><li><a class="toctext" href="#Providing-CmdStan-commandline-arguments-1">Providing CmdStan commandline arguments</a></li><li><a class="toctext" href="#Parameter-optimization-and-approximate-sampling-from-the-posterior-1">Parameter optimization and approximate sampling from the posterior</a></li></ul></li></ul></li><li><a class="toctext" href="../lib/lib.html">Library</a></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="guide.html">Guide</a></li></ul><a class="edit-page" href="https://github.com//blob/master/docs/src/man/guide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Guide</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Package-Guide-1" href="#Package-Guide-1">Package Guide</a></h1><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><pre><code class="language-julia">] add http://132.252.170.166:8000/DanielHa/StanInterface.jl.git</code></pre><h2><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h2><h1><a class="nav-anchor" id="Minimal-working-example-1" href="#Minimal-working-example-1">Minimal working example</a></h1><p>StanInterface is intended to be a simple wrapper for CmdStan that simplifies file handling. To start, consider this simple bernoulli model with a single parameter <code>theta</code>:</p><pre><code class="language-none">data {
    int&lt;lower=0&gt; N;
    int&lt;lower=0,upper=1&gt; y[N];
}
parameters {
    real&lt;lower=0,upper=1&gt; theta;
}
model {
    theta ~ beta(1,1);
    y ~ bernoulli(theta);
}</code></pre><p>To run a model, StanInterface provides the <code>stan</code> function, which requires the path to the Stan model and a dictionary containg the data as input arguments. The input variables of the Stan model are provided as simple String keys to the dictionary:</p><pre><code class="language-julia">julia&gt; using StanInterface

julia&gt; sf = stan(&quot;bernoulli.stan&quot;, Dict(&quot;N&quot; =&gt; 5, &quot;y&quot; = [0,0,0,1,1]))</code></pre><p>This function call automatically compiles the .stan file and runs the model with the provided data. The <code>stan</code> function returns an object of type <code>::Stanfit</code>. To retrieve the MCMC results, call the function <code>extract</code> on the returned <code>::Stanfit</code> object. Results from different chains are merged:</p><pre><code class="language-julia">julia&gt; extract(sf)

Dict{String,Array{Float64,1}} with 8 entries:
  &quot;treedepth__&quot;   =&gt; [1.0, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0,…
  &quot;n_leapfrog__&quot;  =&gt; [1.0, 3.0, 1.0, 1.0, 1.0, 3.0, 3.0, 3.0, 1.0, 3.0  …  3.0,…
  &quot;theta&quot;         =&gt; [0.458652, 0.48066, 0.721026, 0.605692, 0.40698, 0.40698, …
  &quot;energy__&quot;      =&gt; [5.22223, 4.8696, 7.05694, 6.90516, 5.23482, 5.39365, 4.36…
  &quot;lp__&quot;          =&gt; [-4.62739, -4.74118, -7.03734, -5.65588, -4.41062, -4.4106…
  &quot;accept_stat__&quot; =&gt; [1.0, 0.987203, 0.466092, 1.0, 1.0, 0.73413, 1.0, 0.983674…
  &quot;divergent__&quot;   =&gt; [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0,…
  &quot;stepsize__&quot;    =&gt; [0.959187, 0.959187, 0.959187, 0.959187, 0.959187, 0.95918…</code></pre><p>This returns a dictionary of the MCMC results. Among <code>theta</code>, several other parameters are also reported, like the log-posterior <code>lp__</code> and the stepsize <code>stepsize__</code>. If one is just interested in a subset of parameters, the <code>extract</code> function can be called with an optional vector of parameters of interest:</p><pre><code class="language-julia"> julia&gt; extract(sf, [&quot;theta&quot;, &quot;lp__&quot;])

 Dict{String,Array{Float64,1}} with 2 entries:
  &quot;lp__&quot;          =&gt; [-4.62739, -4.74118, -7.03734, -5.65588, -4.41062, -4.4106…
  &quot;theta&quot;         =&gt; [0.458652, 0.48066, 0.721026, 0.605692, 0.40698, 0.40698, …
 ```

By default, Stan is run with 2000 iterations and 4 chains. If possible, chains are run in parallel using Julia&#39;s implementation of message passing, so simpling adding workers with `addprocs(n)` or calling julia with `julia -p n` enables parallel sampling.</code></pre><h2><a class="nav-anchor" id="Accessing-the-content-of-Stanfit-objects-1" href="#Accessing-the-content-of-Stanfit-objects-1">Accessing the content of Stanfit objects</a></h2><p>A <code>::Stanfit</code> object has the fields <code>:model</code>, <code>:data</code>, <code>:iter</code>, <code>:chains</code>, <code>:result</code>, <code>:diagnostics</code>.  <code>:model</code> contains the path to the stan model, <code>:data</code> contains the input dictionary, and <code>:iter</code> and <code>:chains</code> the number of chains and iterations of the MCMC run. The field <code>:result</code> contains a vector of dictionaires of MCMC results (one for each chain). Normally, it is not needed to access this field directly, as <code>extract</code> is provided as a convenience function to merge the different chains automatically. <code>:diagnostics</code> contains a String with possible sampling problems or an empty string (<code>&quot;&quot;</code>) if no problems were found. The diagnostics are done using CmdStan&#39;s built-in diagnose tool, which is described in the <a href="https://github.com/stan-dev/cmdstan/releases/download/v2.17.1/cmdstan-guide-2.17.1.pdf">CmdStan Interface User&#39;s Guide</a>. It checks for the following potential problems (from the CmdStan manual):</p><ul><li>Transitions that hit the maximum treedepth</li><li>Divergent transitions</li><li>Low E-BFMI values</li><li>Low effective ssample sizes</li><li>High R̂ values</li></ul><h2><a class="nav-anchor" id="Additional-keyword-arguments-1" href="#Additional-keyword-arguments-1">Additional keyword arguments</a></h2><p>The <code>stan</code> function also provides the optional keyword parameters <code>save_binary</code>, <code>save_result</code>, <code>save_data</code> and <code>save_diagnostics</code> to save output files at a specific path. For example,</p><pre><code class="language-julia">sf = stan(&quot;bernoulli.stan&quot;, Dict(&quot;N&quot; =&gt; 5, &quot;y&quot; =&gt; [0,0,0,1,1]), 
          save_binary = &quot;~/Desktop/bernoulli_binary&quot;)</code></pre><p>saves the compiled stan binary at the user&#39;s desktop for Unix systems. Please note that executable files need to have an &quot;.exe&quot; file extension in Windows systems. To avoid recompiling the same model repeatedly, the <code>stan</code> function also accepts an executable binary:</p><pre><code class="language-julia">sf = stan(&quot;bernoulli_binary&quot;, Dict(&quot;N&quot; =&gt; 5, &quot;y&quot; = [0,0,0,1,1]))</code></pre><p>An execuatable binary can also be built by using the <code>build_binary(model, path)</code> function.</p><p><code>save_result</code> saves the input data in CmdStans dump data format, which is almost identical to the Rdump data format.</p><h2><a class="nav-anchor" id="Providing-CmdStan-commandline-arguments-1" href="#Providing-CmdStan-commandline-arguments-1">Providing CmdStan commandline arguments</a></h2><p>Most of the models do not require changing Stan&#39;s sampling parameters. If it is necessary to change some sampling parameters, the <code>stan</code> function provides the optional keyword argument `stan_args&#39; as a hook into CmdStan&#39;s command line interface. For example to change the target acceptance rate (which can be tried if divergent transitions occur during sampling) to a value of 0.99, call:</p><pre><code class="language-julia">sf = stan(&quot;bernoulli.stan&quot;, Dict(&quot;N&quot; =&gt; 5, &quot;y&quot; =&gt; [0,0,0,1,1]), 
          stan_args = &quot;adapt delta=0.95&quot;)</code></pre><p>CmdStan&#39;s arguments are hierarchical, which means changing one of the lower level parameters requires setting some parameters before. For example, to change the maximum tree depth of the NUTS sampler, it is required to set <code>stan_args = &quot;algorithm=hmc engine=nuts max_depth=20&quot;</code>. For a full description of possible command line arguments, please refer to the <a href="https://github.com/stan-dev/cmdstan/releases/download/v2.17.1/cmdstan-guide-2.17.1.pdf">CmdStan Interface User&#39;s Guide</a>.</p><h2><a class="nav-anchor" id="Parameter-optimization-and-approximate-sampling-from-the-posterior-1" href="#Parameter-optimization-and-approximate-sampling-from-the-posterior-1">Parameter optimization and approximate sampling from the posterior</a></h2><p>CmdStan can also find the posterior mode or fit a variational approximation to the posterior. To access these functions, call <code>stan</code> with the additional argument <code>&quot;optimize&quot;</code> or <code>&quot;variational&quot;</code>:</p><pre><code class="language-julia">julia&gt; sf = stan(&quot;bernoulli.stan&quot;, Dict(&quot;N&quot; =&gt; 5, &quot;y&quot; =&gt; [0,0,0,0,1]), &quot;optimize&quot;)
julia&gt; extract(sf)

Dict{String,Array{Float64,1}} with 2 entries:
  &quot;theta&quot; =&gt; [0.200004] 
  &quot;lp__&quot;  =&gt; [-2.50201]</code></pre><p>The value of <code>theta</code> corresponds to the posterior mode of 0.2 (1 &quot;success&quot; out of 5 attepts). <code>stan_args</code> can be used to set additional Stan parameters and files can be saved via the <code>save_</code> keyword arguments.</p><p>To get 1 million samples from the approximate posterior:</p><pre><code class="language-julia">julia&gt; sf = stan(&quot;bernoulli.stan&quot;, Dict(&quot;N&quot; =&gt; 5, &quot;y&quot; =&gt; [0,0,0,0,1]), &quot;variational&quot;,
                 stan_args=&quot;algorithm=meanfield iter=1000000&quot;)</code></pre><p>Note that the hierarchical structure of CmdStan parameters requires setting &quot;algorithm=meanfield&quot; in order to access the &quot;iter&quot; parameter.</p><footer><hr/><a class="previous" href="../home.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../lib/lib.html"><span class="direction">Next</span><span class="title">Library</span></a></footer></article></body></html>
